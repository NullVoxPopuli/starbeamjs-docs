import{_ as r,r as n,o as a,c as i,b as t,d as l,a as s,e}from"./app.87201e6c.js";const d={},c=s('<h1 id="rendering-into-a-template" tabindex="-1"><a class="header-anchor" href="#rendering-into-a-template" aria-hidden="true">#</a> Rendering Into a Template</h1><p>The second kind of renderer is a Render-Into-Template renderer.</p><p>This kind of renderer is for components that create some sort of data structure on initial render, and then use it to efficiently update the output when the inputs change.</p><p>For a &quot;Render-Into-Template&quot; renderer, you need to:</p><ol><li>Identify distinct framework-provided hooks for: <ol><li>Before initial render</li><li>After initial render</li><li>Before update</li><li>After update</li></ol></li><li>Figure out how to notify the framework that you want it to re-render.</li><li>Figure out how to get a representation of the &quot;component instance&quot;, which you will link resource lifetimes to.</li></ol><p>Importantly, the hooks you identify should surround <strong>all reads</strong> from reactive values, but <strong>none of the writes</strong> to reactive values, which logically happen during the Starbeam action phase.</p>',6),h=e("The "),p={href:"https://github.com/chiragpat/starbeam-svelte",target:"_blank",rel:"noopener noreferrer"},u=e("svelte renderer"),f=e(" is a good example of this kind of renderer.");function m(_,g){const o=n("ExternalLinkIcon");return a(),i("div",null,[c,t("p",null,[h,t("a",p,[u,l(o)]),f])])}var v=r(d,[["render",m],["__file","2-render-template.html.vue"]]);export{v as default};
